#!/usr/bin/env ruby
$:.unshift(File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib')))
require 'rubygems'
require 'open-uri'
require 'bitcache'
require 'bitcache/client/cli'

module Bitcache::Commands
  class Bit < Bitcache::CLI::Base
    include Bitcache

    URL_PATTERN = /^[\w\d-]+:\/\//

    banner "Usage: #{basename} [options] command ..."

    option '-d', '--debug', 'Enable debug output for troubleshooting.', lambda { $DEBUG = $VERBOSE = $OPTIONS[:verbose] = true }
    option '-v', '--verbose', 'Enable verbose output. May be given more than once.', lambda { $OPTIONS[:verbose] = true }
    option '-V', '--version', 'Display the Bitcache version, and exit.', lambda { abort "Bitcache #{Bitcache::VERSION::STRING}" }
    option '-?', '--help', 'Display this help message.', lambda { @@cmd = :help }
    option '-c', '--config FILE', 'Specify configuration file (default: ~/.bitrc).', lambda { |arg| $OPTIONS[:config] = arg.to_s }
    option '-1', '--id-only', 'Display nothing but bitstream identifiers in listings.', lambda { $OPTIONS[:id_only] = true }
    option '-e', '--encoding ENC', 'Decode input or encode output with [base64, gzip, bzip2].', lambda { |enc| $OPTIONS[:encoding] = enc.to_sym }
    option '-s', '--source SRC', 'Limit all operations to a specific repository.', lambda { |src| $OPTIONS[:source] = src.to_s }
    option '-i', '--include ID', 'Limit all operations to specific bitstreams.', lambda { |arg| ($OPTIONS[:include] ||= []) << arg.to_s }
    option '-x', '--exclude ID', 'Limit all operations to specific bitstreams.', lambda { |arg| ($OPTIONS[:exclude] ||= []) << arg.to_s }
    option '-u', '--username USER', 'Specify a user name for repository authentication.', lambda { |arg| $OPTIONS[:username] = arg.to_s }
    option '-p', '--password PASS', 'Specify a password for repository authentication', lambda { |arg| $OPTIONS[:password] = arg.to_s }

    ###
    ## Command: sources | src

    command([:sources, :src], nil, :help => "Display repository list.") do
      repos.each do |name, repo|
        name = (repo == default) ? "#{name}*" : name
        puts [name.to_s.ljust(40), repo.size.to_s.rjust(12), repo.uri].join(' ').rstrip
      end
    end

    ###
    ## Command: list | ls

    command([:list, :ls], :repo, :help => "List bitstreams.") do |*filters|
      filter = filters.first
      repos.each do |name, repo|
        next unless repo.allowed?(:list)
        repo.each(filter) do |stream|
          next if filter && stream.id.index(filter) != 0
          puts $OPTIONS[:id_only] ? stream.id.to_s :
            [stream.id.to_s.ljust(40), stream.size.to_s.rjust(12), stream.uri].join(' ').rstrip
        end
      end
    end

    ###
    ## Command: has | exists | known

    command([:has, :exists, :known], :id, :help => "Check whether a given bitstream is known.") do |id|
      ensure_valid_id!(id = id.downcase)
      puts default.include?(id) ? 'yes' : 'no'
    end

    ###
    ## Command: identify | id

    command([:identify, :id], :file, :help => "Identify a file.") do |file|
      ensure_files_exist!(file)
      puts Stream.hash(file)
    end

    ###
    ## Command: put | upload | up

    command([:put, :upload, :up], [:file, true], :help => "Import files.") do |*files|
      ensure_files_exist!(*files)
      if repo = default
        files.each do |file|
          if id = repo << (file =~ URL_PATTERN ? URI.parse(file) : Pathname.new(file))
            puts $OPTIONS[:verbose] ? "#{id}: #{file}" : id
          end
        end
      else
        abort "#{basename}: no default repository specified."
      end
    end

    ###
    ## Command: get | download | cat

    command([:get, :download, :cat], :id, :help => "Export a bitstream.") do |id|
      ensure_valid_id!(id = id.downcase)
      if data = default[id].read
        puts data
      else
        abort "#{basename}: #{id}: no such bitstream found."
      end
    end

    ###
    ## Command: delete | del | rm

    command([:delete, :del, :rm], :id, :help => "Delete a bitstream.") do |*ids|
      ids.map! { |id| id.downcase }
      ids.each { |id| ensure_valid_id!(id) }
      exit ids.all? { |id| default.delete!(id) } ? 0 : 1
    end

    ###
    ## Command: export | archive

    command([:export, :archive], :file, :help => "...", :enabled => false) do |file|
      # TODO
    end

    ###
    ## Command: import | unarchive

    command([:import, :unarchive], :file, :help => "...", :enabled => false) do |file|
      # TODO
    end

    ###
    ## Command: sync

    command([:sync], [:repo1, :repo2, true], :help => "Synchronize repositories.") do |*sync_repos|
      abort "Usage: #{basename} sync [options] repo1 repo2 ..." unless sync_repos.size >= 2

      sync_repos = sync_repos.map { |name| @repos[name.to_sym] }
      sync_keys = map_concurrently(sync_repos) { |repo| repo.keys }

      sync_repos.zip(sync_keys) do |repo1, keys1|
        sync_repos.clone.zip(sync_keys).delete_if { |r, k| r == repo1 }.each do |repo2, keys2|
          diff = (keys1 - keys2).delete_if { |key| repo2.include?(key) }
          unless diff.empty?
            puts "Synchronizing #{repo1.uri} => #{repo2.uri} (#{diff.size} items)..."

            diff.each do |key|
              next if $OPTIONS[:exclude] && $OPTIONS[:exclude].include?(key)
              next if $OPTIONS[:include] && !$OPTIONS[:include].include?(key)
              print "#{key}: "
              puts repo2.put!(key, repo1.get(key)) ? 'done.' : 'FAILED.'
            end
          end
        end
      end
    end

    ###
    ## Command: debug (hidden)

    command([:debug], nil) { puts $OPTIONS.inspect }

    protected

      def run
        @repos = Config.load_repos($OPTIONS)
        super
      end

    private

      def repos
        @repos
      end

      def default
        @default ||=
          @repos[:default] ||
          @repos.values.find { |repo| repo.config[:default] } ||
          @repos.values.find { |repo| repo.config[:adapter] == 'file' } ||
          @repos[@repos.keys.first]
      end

      ##
      # Returns a new array containing the results of running `block`
      # concurrently (in separate threads) for every element in `enum`.
      def map_concurrently(enum, &block)
        threads = []
        enum.each { |item| threads << Thread.new(item, &block) }
        threads.map { |thread| thread.value }
      end

      def ensure_files_exist!(*files)
        files.each do |file|
          if file !~ URL_PATTERN # skip over any URLs, at this stage
            path = Pathname.new(file)
            abort "#{basename}: #{file}: no such file." unless path.exist?
            abort "#{basename}: #{file}: not a file." unless path.file? || path.symlink?
            abort "#{basename}: #{file}: permission denied." unless path.readable?
          end
        end
      end

      def ensure_valid_id!(id)
        abort "#{basename}: #{id}: invalid bitstream identifier." unless id =~ Stream::ID_FORMAT || $DEBUG
      end
  end
end
