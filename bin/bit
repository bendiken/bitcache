#!/usr/bin/env ruby
$:.unshift(File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib')))
require 'rubygems'
require 'bitcache'
require 'bitcache/client/cli'

module Bitcache::Commands
  class Bit < Bitcache::CLI::Base
    include Bitcache

    banner "Usage: #{File.basename($0)} [options] command ..."

    option '-d', '--debug', 'Enable debug output for troubleshooting.', lambda { $DEBUG = $VERBOSE = $OPTIONS[:verbose] = true }
    option '-e', '--encoding ENC', 'Decode input or encode output with [base64, gzip, bzip2].', lambda { |enc| $OPTIONS[:encoding] = enc.to_sym }
    option '-s', '--source SRC', 'Limit all operations to a specific repository.', lambda { |src| $OPTIONS[:source] = src.to_s }
    option '-v', '--verbose', 'Enable verbose output. May be given more than once.', lambda { $OPTIONS[:verbose] = true }
    option '-V', '--version', 'Display the Bitcache version, and exit.', lambda { abort "Bitcache #{Bitcache::VERSION::STRING}" }
    option '-?', '--help', 'Display this help message.', lambda { @@cmd = :help }

    ###
    ## Command: sources | src

    command([:sources, :src], nil, :help => "Display repository list.") do
      @repos.each do |name, repo|
        name = (repo == default) ? "#{name}*" : name
        puts "#{name.to_s.ljust(40)} #{repo.size.to_s.rjust(12)} #{repo.uri}".rstrip
      end
    end

    ###
    ## Command: list | ls

    command([:list, :ls], :repo, :help => "List bitstreams.") do |*filters|
      filter = filters.first
      @repos.each do |name, repo|
        next unless repo.allowed?(:list)
        repo.each(filter) do |stream|
          next if filter && stream.id.index(filter) != 0
          puts [stream.id.to_s.ljust(40), stream.size.to_s.rjust(12), stream.uri].join(' ').rstrip
        end
      end
    end

    ###
    ## Command: has | exists | known

    command([:has, :exists, :known], :id, :help => "Check whether a given bitstream is known.") do |id|
      puts default.include?(id) ? 'yes' : 'no'
    end

    ###
    ## Command: identify | id

    command([:identify, :id], :file, :help => "Identify a file.") do |file|
      puts Stream.hash(file)
    end

    ###
    ## Command: put | upload | up

    command([:put, :upload, :up], [:file, true], :help => "Import files.") do |*files|
      if repo = default
        files.each do |file|
          if id = repo << Pathname.new(file)
            puts $OPTIONS[:verbose] ? "#{id}: #{file}" : id
          end
        end
      else
        raise "No default repository specified."
      end
    end

    ###
    ## Command: get | download | cat

    command([:get, :download, :cat], :id, :help => "Export a bitstream.") do |id|
      if data = default[id].read
        puts data
      else
        warn "bit: #{id}: no such bitstream found."
        exit 1
      end
    end

    ###
    ## Command: delete | del | rm

    command([:delete, :del, :rm], :id, :help => "Delete a bitstream.") do |id|
      default.delete!(id)
    end

    ###
    ## Command: export | archive

    command([:export, :archive], :file, :help => "...", :enabled => false) do |file|
      # TODO
    end

    ###
    ## Command: import | unarchive

    command([:import, :unarchive], :file, :help => "...", :enabled => false) do |file|
      # TODO
    end

    protected

      def run
        @repos = Config.load_repos
        super
      end

    private

      def default
        @default ||=
          @repos[:default] ||
          @repos.values.find { |repo| repo.config[:default] } ||
          @repos.values.find { |repo| repo.config[:adapter] == 'file' } ||
          @repos[@repos.keys.first]
      end

  end
end
