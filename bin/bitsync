#!/usr/bin/env ruby
$:.unshift(File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib')))
require 'rubygems'
require 'bitcache'
require 'bitcache/client/cli'

module Bitcache::Commands
  class Bitsync < Bitcache::CLI::Base
    include Bitcache

    banner "Usage: #{File.basename($0)} [options] repo1 repo2 ..."

    option '-V', '--version', 'Display the Bitcache version, and exit.', lambda { abort "Bitcache #{Bitcache::VERSION::STRING}" }
    option '-?', '--help', 'Display this help message.', lambda { ARGV = ['help'] }

    def start(*sync_repos)
      sync_repos = sync_repos.map { |name| @repos[name.to_sym] }
      sync_keys = sync_repos.map_concurrently { |repo| repo.keys }

      sync_repos.zip(sync_keys) do |repo1, keys1|
        sync_repos.clone.zip(sync_keys).delete_if { |r, k| r == repo1 }.each do |repo2, keys2|
          diff = (keys1 - keys2).delete_if { |key| repo2.include?(key) }
          unless diff.empty?
            puts "Synchronizing #{repo1.uri} => #{repo2.uri} (#{diff.size} items)..."

            diff.each do |key|
              print "#{key}: "
              puts repo2.put!(key, repo1.get(key)) ? 'done.' : 'FAILED.'
            end
          end
        end
      end
    end

    protected

      def run
        @repos = Config.load_repos
        @argv.empty? ? help : start(*@argv)
      end

  end
end
